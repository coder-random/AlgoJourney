# 前言

数组排序是计算机科学中最基本、最常见的问题之一。无论是在算法竞赛、系统开发，还是数据处理场景中，排序几乎无处不在。针对不同的数据规模、数据特性和实际需求，计算机科学家们设计了多种排序算法，每种算法都有各自的特点与适用场景。

排序算法通常从以下几个方面进行比较和选择：

- **时间复杂度**：不同算法在最好、最坏和平均情况下的运行效率差异很大。
- **空间复杂度**：是否需要额外的存储空间，影响算法在内存受限环境下的适用性。
- **稳定性**：相等元素在排序后是否保持原有相对顺序。
- **原地性**：是否能在原数组上完成排序，而不额外占用大量空间。

常见的排序算法包括冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序，以及计数排序、桶排序、基数排序等。不同算法在小规模、大规模、有序度高或低、数据分布特点不同的情况下，表现差异显著。

在实际应用中，排序算法的选择往往需要综合考虑数据规模、数据特性、稳定性要求以及硬件环境。例如：小规模数据常用插入排序；大规模数据一般采用快速排序、归并排序或堆排序；当对稳定性有要求时，可以选择归并排序或计数排序。

因此，掌握各种排序算法的原理与适用场景，不仅是算法学习的必修课，也是提升编程能力和工程实践水平的重要基础。

# 排序算法基础：从“比大小”到“排好序”
面向零基础同学，本文带你从“如何比较两个数谁大谁小”一步步走到“把一串数排好序”。我们用生活类比和清晰的 C 语言代码讲解三种入门排序：
- 冒泡排序（Bubble Sort）
- 选择排序（Selection Sort）
- 插入排序（Insertion Sort）

并给出统一的测试程序、练习题与常见易错点。

## 从“比大小”到“排好序”
- 比较：给你两个数 a 和 b，一次比较就知道谁大谁小。
- 找最小/最大：一串数里用“当前最小值”和后面逐个比较来更新。
- 排序：让所有数从小到大排好，可通过“相邻比较并交换”“每轮挑最小放前面”“维护前缀有序并插入新元素”等思路实现。

三种算法核心记忆：
- 冒泡：相邻比较，较大的“冒”到右边；一轮确定一个“最大”在队尾。
- 选择：每轮从剩余元素里“选择”最小的，放到当前最前面。
- 插入：像抓扑克牌，把新牌“插入”到已经有序的手牌中。

## 冒泡排序（Bubble Sort）
直觉类比：水中气泡会上浮。在一轮比较中，大的数字通过相邻交换“冒”到更右边。第一轮结束，最大值会到最右端；第二轮结束，次大到倒数第二个……直到全部有序。

- 步骤（升序）：
  1) 从左到右比较相邻元素，若左 > 右则交换。
  2) 一轮结束后，最大值到最右端。
  3) 下一轮比较范围缩小 1。
  4) 若某一轮没有发生交换，说明整体已有序，可提前结束（优化）。

- 稳定性：稳定（相等元素的相对顺序不变）。
- 时间复杂度：最坏/平均 O(n^2)；若数组几乎有序并使用提前结束优化，接近 O(n)。
- 缺点：交换次数可能较多。

示例（[5, 3, 4, 2]）简要过程：
- 第1轮：5|3 换 -> [3,5,4,2]；5|4 换 -> [3,4,5,2]；5|2 换 -> [3,4,2,5]
- 第2轮：3|4 不换；4|2 换 -> [3,2,4,5]
- 第3轮：3|2 换 -> [2,3,4,5] 完成

C 实现（含提前结束优化）：
```c
#include <stdbool.h>

void bubble_sort(int a[], int n) {
    if (n <= 1) return;
    for (int end = n - 1; end > 0; --end) {
        bool swapped = false;
        for (int i = 0; i < end; ++i) {
            if (a[i] > a[i + 1]) {
                int tmp = a[i];
                a[i] = a[i + 1];
                a[i + 1] = tmp;
                swapped = true;
            }
        }
        if (!swapped) break; // 无交换，提前结束
    }
}
```

可选优化：记录“最后一次交换位置 lastSwap”，下一轮只需比较到 lastSwap 处，进一步缩小范围。

## 选择排序（Selection Sort）
直觉类比：每回合在还没放好的元素里“挑出最小的”，放到最前面应在的位置。

- 步骤（升序）：
  1) 第 i 轮（i 从 0 开始）：在区间 [i, n-1] 找到最小值的下标 min_idx。
  2) 交换 a[i] 与 a[min_idx]，把最小元素就位。
  3) i 之前的元素已有序，继续下一轮。

- 稳定性：常见实现不稳定（可能打乱相等元素的先后顺序）。
- 时间复杂度：无论最好/最坏/平均，都是 O(n^2)。
- 特点：比较次数固定较多，但交换次数至多 n-1（通常比冒泡少）。

C 实现（常见不稳定版）：
```c
void selection_sort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 0; i < n - 1; ++i) {
        int min_idx = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[min_idx]) {
                min_idx = j;
            }
        }
        if (min_idx != i) {
            int tmp = a[i];
            a[i] = a[min_idx];
            a[min_idx] = tmp;
        }
    }
}
```

如何让选择排序“稳定”？思路：不直接交换最小元素到前面，而是“抽出最小值，右移中间元素一格，再把最小值插回去”。参考实现：
```c
// 稳定的选择排序：通过移动元素而非直接交换实现稳定性
void stable_selection_sort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 0; i < n - 1; ++i) {
        int min_idx = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[min_idx]) min_idx = j;
        }
        int key = a[min_idx];
        // 将区间 [i, min_idx-1] 的元素整体右移一格
        for (int k = min_idx; k > i; --k) {
            a[k] = a[k - 1];
        }
        a[i] = key;
    }
}
```

## 插入排序（Insertion Sort）
直觉类比：打牌抓牌。你左手的牌保持有序，新抓一张牌时，从右往左比较，把它插入到合适位置，保持“手牌”有序。

- 步骤（升序）：
  1) 视 a[0] 为已排序区间。
  2) 从 i=1 开始，取出 a[i] 为待插入元素 key。
  3) 从已排序区间的右端向左扫描，凡比 key 大的元素都右移一位。
  4) 在空出的正确位置放入 key。
  5) 已排序区间扩大 1。

- 稳定性：稳定。
- 时间复杂度：最坏/平均 O(n^2)；当数据“几乎有序”时非常快，接近 O(n)。
- 特点：以“移动”为主，实际表现常优于冒泡。

C 实现：
```c
void insertion_sort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 1; i < n; ++i) {
        int key = a[i];
        int j = i - 1;
        // 将比 key 大的元素右移
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            --j;
        }
        a[j + 1] = key;
    }
}
```

## 三者快速对比与选型建议
- 思路对比
  - 冒泡：相邻比较，大的不断“冒”到右边。
  - 选择：每轮从剩余元素里“挑最小”放前面。
  - 插入：维护前缀有序，把新元素插入正确位置。
- 稳定性：冒泡、插入稳定；选择排序（常见实现）不稳定（可改为稳定实现）。
- 时间复杂度：平均/最坏均 O(n^2)；插入在“几乎有序”时近似 O(n)。
- 实战建议：
  - 数据量小或几乎有序：优先插入排序。
  - 教学演示直观：冒泡、插入都合适。
  - 想减少交换次数：选择排序（但比较次数并不减少，且要注意稳定性）。

## 测试程序
可以把三种算法放在同一文件中测试。注意：函数会就地修改数组，若需多算法对比，可先拷贝一份数组。

```c
#include <stdio.h>
#include <stdbool.h>

void print_array(const int a[], int n, const char* name) {
    printf("%s: [", name);
    for (int i = 0; i < n; ++i) {
        printf("%d", a[i]);
        if (i + 1 < n) printf(", ");
    }
    printf("]\n");
}

void copy_array(const int src[], int dst[], int n) {
    for (int i = 0; i < n; ++i) dst[i] = src[i];
}

void bubble_sort(int a[], int n);
void selection_sort(int a[], int n);
void stable_selection_sort(int a[], int n); // 可选
void insertion_sort(int a[], int n);

int main(void) {
    int sets[][8] = {
        {},                  // 空数组（占位，长度标 0）
        {1},
        {5, 3, 4, 2},
        {2, 3, 4, 5},
        {5, 4, 3, 2},
        {3, 3, 2, 1, 2}
    };
    int lens[] = {0, 1, 4, 4, 4, 5};
    const int cases = sizeof(lens) / sizeof(lens[0]);

    for (int c = 0; c < cases; ++c) {
        int n = lens[c];
        int a[8], b[8], d[8], e[8];
        copy_array(sets[c], a, n);
        copy_array(sets[c], b, n);
        copy_array(sets[c], d, n);
        copy_array(sets[c], e, n);

        printf("原始: ");
        print_array(sets[c], n, "arr");

        bubble_sort(a, n);
        print_array(a, n, "bubble_sort");

        selection_sort(b, n);
        print_array(b, n, "selection_sort");

        insertion_sort(d, n);
        print_array(d, n, "insertion_sort");

        // 可对比稳定选择
        stable_selection_sort(e, n);
        print_array(e, n, "stable_selection_sort");

        printf("------------------------------\n");
    }
    return 0;
}

/* 实现区 */

void bubble_sort(int a[], int n) {
    if (n <= 1) return;
    for (int end = n - 1; end > 0; --end) {
        bool swapped = false;
        for (int i = 0; i < end; ++i) {
            if (a[i] > a[i + 1]) {
                int tmp = a[i];
                a[i] = a[i + 1];
                a[i + 1] = tmp;
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}

void selection_sort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 0; i < n - 1; ++i) {
        int min_idx = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[min_idx]) min_idx = j;
        }
        if (min_idx != i) {
            int tmp = a[i];
            a[i] = a[min_idx];
            a[min_idx] = tmp;
        }
    }
}

void stable_selection_sort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 0; i < n - 1; ++i) {
        int min_idx = i;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[min_idx]) min_idx = j;
        }
        int key = a[min_idx];
        for (int k = min_idx; k > i; --k) {
            a[k] = a[k - 1];
        }
        a[i] = key;
    }
}

void insertion_sort(int a[], int n) {
    if (n <= 1) return;
    for (int i = 1; i < n; ++i) {
        int key = a[i];
        int j = i - 1;
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            --j;
        }
        a[j + 1] = key;
    }
}
```

## 常见易错点
- 冒泡排序：
  - 内层循环没有随外层轮次缩小范围。
  - 忘记提前结束优化，已排序数组仍做无用比较。
- 选择排序：
  - 每轮未把 min_idx 重置为 i。
  - 误以为选择排序稳定（常见实现并不稳定）。
- 插入排序：
  - while 条件写反或漏掉 j >= 0 的边界判断。
  - 忘记在正确位置回填 key。
- 通用：
  - 交换时用错下标或丢失临时变量导致数据覆盖。
  - 打印数组忘记传长度或越界访问。

## 总结
- 冒泡、选择、插入是排序入门三基石，帮助理解“比较”“交换/移动”“有序区间扩展”等核心思想。
- 进阶方向：归并排序、快速排序、堆排序（更高效的比较排序），以及计数/桶/基数排序（非比较排序）。

## 学习路线

更多算法学习内容以及题单请访问 [ 「 算法特训 」](https://leetcode.cn/discuss/post/3751908/fen-xiang-suan-fa-jing-sai-te-xun-ru-men-59di/)