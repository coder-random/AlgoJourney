# 二分查找

## 基本概念

二分查找（Binary Search）是一种在 **有序数组** 中查找目标元素的高效算法。
 它通过不断将查找区间折半，逐步缩小范围，从而快速定位目标。

**特点：**

- 时间复杂度：O(log n)
- 空间复杂度：O(1)
- 需要数据 **有序**（升序或降序都可以，以下讲义默认升序）
- 适合 **数组**，不适合链表

## 算法思想

假设在升序数组 `arr[0...n-1]` 中查找元素 `target`：

1. 设定左右边界 `l=0, r=n-1`。
2. 取中点 `mid = (l + r) / 2`（防止溢出写作 `l + (r-l)/2`）。
3. 判断：
   - `arr[mid] == target` → 返回 `mid`
   - `arr[mid] < target` → 目标在右区间 `[mid+1, r]`
   - `arr[mid] > target` → 目标在左区间 `[l, mid-1]`
4. 重复以上步骤，直到 `l > r` 结束循环。
5. 若未找到，返回 -1。

## 代码实现（标准二分查找）

```c
#include <stdio.h>

int binarySearch(int arr[], int n, int target) {
    int l = 0, r = n - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2; // 避免 (l+r) 溢出
        if (arr[mid] == target) {
            return mid; // 找到返回下标
        } else if (arr[mid] < target) {
            l = mid + 1; // 去右半区
        } else {
            r = mid - 1; // 去左半区
        }
    }
    return -1; // 未找到
}

int main() {
    int nums[] = {1, 3, 5, 7, 9, 11};
    int n = sizeof(nums) / sizeof(nums[0]);
    int target = 7;

    int idx = binarySearch(nums, n, target);
    if (idx != -1) {
        printf("找到 %d, 下标为 %d\n", target, idx);
    } else {
        printf("未找到 %d\n", target);
    }

    return 0;
}
```

**输出：**

```
找到 7, 下标为 3
```

## 示例演示

查找 `target=7` 在数组 `{1, 3, 5, 7, 9, 11}` 中的过程：

1. `l=0, r=5 → mid=2 → arr[2]=5 < 7` → 去右边 `[3,5]`
2. `l=3, r=5 → mid=4 → arr[4]=9 > 7` → 去左边 `[3,3]`
3. `l=3, r=3 → mid=3 → arr[3]=7 == target` → 找到，返回 3

## 复杂度分析

- **时间复杂度**：O(log n)
   每次查找都将区间缩小一半。
- **空间复杂度**：O(1)
   只使用了常数级的变量。

## 变体（边界查找）

在很多题目中，我们不仅要找到一个目标，还需要：

1. **查找左边界（lower bound）**

   - 找到第一个大于等于 `target` 的位置

   ```c
   int lowerBound(int arr[], int n, int target) {
       int l = 0, r = n;
       while (l < r) {
           int mid = l + (r - l) / 2;
           if (arr[mid] < target) {
               l = mid + 1;
           } else {
               r = mid;
           }
       }
       return l; // 可能等于 n
   }
   ```

2. **查找右边界（upper bound）**

   - 找到第一个大于 `target` 的位置

   ```c
   int upperBound(int arr[], int n, int target) {
       int l = 0, r = n;
       while (l < r) {
           int mid = l + (r - l) / 2;
           if (arr[mid] <= target) {
               l = mid + 1;
           } else {
               r = mid;
           }
       }
       return l; // 可能等于 n
   }
   ```

## 注意事项

- **数组必须有序**，否则结果不正确。
- **避免死循环**：循环条件必须是 `l <= r` 或 `l < r`，并正确更新边界。
- **避免溢出**：中点计算用 `mid = l + (r - l) / 2`，而不是 `(l + r)/2`。
- **多解问题**：如果数组中有多个相同值，要用 **左/右边界查找** 版本。

## 总结

二分查找是一个经典的对数时间算法，常用于 **查找、边界定位、答案判定** 等场景。
 掌握它不仅能提升代码能力，也是很多算法题的基础（如求最小值/最大值、判定性问题等）。

## 学习路线

更多算法学习内容以及题单请访问 [ 「 算法特训 」](https://leetcode.cn/discuss/post/3751908/fen-xiang-suan-fa-jing-sai-te-xun-ru-men-59di/)