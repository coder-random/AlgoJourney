# 前缀和与差分

## 什么是前缀和（Prefix Sum）

 **直观理解**：
 你有一条数轴，把数组元素从左到右不断累加，就得到一个“累积表”。
 以后你想知道某个区间 `[l,r]` 的和，只要看累积表在 `r` 和 `l-1` 的差即可。

 **定义**（一维，0-based）：
 给定数组 `a[0..n-1]`，前缀和数组 `pre[0..n-1]` 定义为：

pre[i]=a[0]+a[1]+⋯+a[i]

那么任意区间和：

sum(l,r)=pre[r]−(l>0?pre[l−1]:0)

 **例子**：
 `a = [2, 4, 6, 8]`
 `pre = [2, 6, 12, 20]`
 要算 `[1,3]` 的和（4+6+8=18），只需 `pre[3] - pre[0] = 20 - 2 = 18`。

 **特点**：

- **适合查询频繁**，更新很少的情况（一次建表，多次查询 O(1)）。
- 可推广到二维（矩阵求子矩阵和）。

------

## 什么是差分（Difference Array）

 **直观理解**：
 差分相当于“记录相邻元素的变化”。
 如果前缀和是“积分”，差分就是“导数”。

 **定义**（一维，0-based）：
 给定数组 `a[0..n-1]`，构造差分数组 `d[0..n-1]`：

d[0]=a[0],d[i]=a[i]−a[i−1]  (i≥1)

这样，原数组可以通过差分的前缀和还原：

a[i]=d[0]+d[1]+⋯+d[i]

 **核心用法：区间加法**
 如果要让区间 `[l,r]` 所有元素都加上一个数 `v`：

- 只需执行：

  ```
  d[l] += v;
  if (r+1 < n) d[r+1] -= v;
  ```

- 最后再用差分数组还原，就得到了修改后的完整数组。

**例子**：
 `a = [0,0,0,0,0]`
 做操作 `[1,3] +2`：
 `d[1]+=2, d[4]-=2`。
 还原后 `a = [0,2,2,2,0]`。

 **特点**：

- **适合修改频繁**，查询不多或只在最后一次性输出。
- 可推广到二维（矩阵做矩形加法）。

## 总结对比

| 方法   | 用途           | 原理                   | 典型操作                                |
| ------ | -------------- | ---------------------- | --------------------------------------- |
| 前缀和 | 快速求区间和   | `pre[i]=a[0]+...+a[i]` | `sum(l,r)=pre[r]-pre[l-1]`              |
| 差分   | 快速做区间修改 | `d[i]=a[i]-a[i-1]`     | 区间 `[l,r]` 加 v：`d[l]+=v; d[r+1]-=v` |

**一句话记忆**：
  **要查区间和 → 前缀和**
  **要改区间值 → 差分**

好——下面我把前缀和（prefix sum）与差分（difference array）**用 C 语言**从原理、实现到常见应用与易错点讲清楚，并给出可编译、可运行的示例代码。所有代码均使用 **0-based 索引**（因为 C 里数组天然是 0-based），并用 `long long` 做累加以降低溢出风险。阅读顺序建议：先看 1D 前缀和 → 1D 差分 → 2D 前缀和 → 2D 差分。每段都给「原理」+「代码」+「示例与说明」。

## 总的直觉（0-based）

- **前缀和**：预先把 `pre[i] = a[0] + a[1] + ... + a[i]` 算好，任意区间 `[l, r]` 和为 `sum(l,r) = pre[r] - (l>0 ? pre[l-1] : 0)`。适合「多次查询区间和、数组不频繁修改」的场景。
- **差分**：维护差分数组 `d`，其中 `d[0] = a[0]`, `d[i] = a[i] - a[i-1] (i>0)`。区间加值 `[l,r] += v` 只需 `d[l] += v; if (r+1 < n) d[r+1] -= v;`。最后把 `d` 前缀和一次得到最终 `a`。适合「大量区间修改 + 最终得到结果/少量查询」的场景。

## 1D 前缀和

原理：构建 `pre[i]`（包含 `a[0]` 到 `a[i]`），查询 `sum(l,r)` O(1)。

```c
/* prefix_sum_1d.c
   编译: gcc prefix_sum_1d.c -o prefix_sum_1d
*/
#include <stdio.h>
#include <stdlib.h>

long long* build_prefix(const long long *a, int n) {
    // 返回长度 n 的 pre，pre[i] = sum(a[0..i])
    long long *pre = (long long*)malloc(sizeof(long long) * n);
    if (!pre) { perror("malloc"); exit(EXIT_FAILURE); }
    long long s = 0;
    for (int i = 0; i < n; ++i) {
        s += a[i];
        pre[i] = s;
    }
    return pre;
}

long long range_sum(const long long *pre, int l, int r) {
    if (l == 0) return pre[r];
    return pre[r] - pre[l-1];
}

// 示例主函数
int main() {
    int n = 8;
    long long a[] = {1, 2, 3, 4, 5, 6, 7, 8};
    long long *pre = build_prefix(a, n);

    printf("sum(2,5) = %lld\n", range_sum(pre, 2, 5)); // 3+4+5+6 = 18
    printf("sum(0,7) = %lld\n", range_sum(pre, 0, 7)); // 36

    free(pre);
    return 0;
}
```

说明与注意：

- 时间：构建 O(n)，每次查询 O(1)。
- 如果数组会频繁修改（单点修改或区间修改），前缀和需要重建或配合树状数组/线段树使用。

## 1D 差分

原理回顾（0-based）：

- 初始 `d[0] = a[0]`, `d[i] = a[i] - a[i-1]`（1 ≤ i < n）。
- 区间加 `v` 到 `[l,r]`：`d[l] += v; if (r+1<n) d[r+1] -= v;`
- 最终还原 `a`：`a[0] = d[0]; a[i] = a[i-1] + d[i]`（等价于对 d 做前缀和）。

```c
/* diff_1d.c
   编译: gcc diff_1d.c -o diff_1d
*/
#include <stdio.h>
#include <stdlib.h>

long long* make_diff_from_array(const long long *a, int n) {
    long long *d = (long long*)calloc(n, sizeof(long long));
    if (!d) { perror("calloc"); exit(EXIT_FAILURE); }
    if (n > 0) d[0] = a[0];
    for (int i = 1; i < n; ++i) d[i] = a[i] - a[i-1];
    return d;
}

void range_add(long long *d, int n, int l, int r, long long v) {
    if (l < 0 || r >= n || l > r) return;
    d[l] += v;
    if (r + 1 < n) d[r + 1] -= v;
}

long long* materialize_from_diff(const long long *d, int n) {
    long long *a = (long long*)malloc(sizeof(long long) * n);
    if (!a) { perror("malloc"); exit(EXIT_FAILURE); }
    long long s = 0;
    for (int i = 0; i < n; ++i) {
        s += d[i];
        a[i] = s;
    }
    return a;
}

int main() {
    int n = 8;
    long long a[] = {0,0,0,0,0,0,0,0}; // 初始全 0
    long long *d = make_diff_from_array(a, n);

    // 做几次区间更新
    range_add(d, n, 2, 5, 3); // a[2..5] += 3
    range_add(d, n, 0, 2, -1); // a[0..2] += -1
    range_add(d, n, 4, 4, 7); // a[4] += 7

    long long *res = materialize_from_diff(d, n);
    printf("final array: ");
    for (int i = 0; i < n; ++i) printf("%lld ", res[i]);
    printf("\n");
    // 解释: 结果应为 [-1,-1,2,3,9,3,0,0]

    free(d);
    free(res);
    return 0;
}
```

说明与注意：

- 差分操作是 O(1)（只改两端），最终一次 O(n) 还原。
- 常见用途：大量区间加后只需最后结果；也常用于离线处理字符串位移、计数等问题。
- 边界要注意 `r+1 < n` 检查；使用 `n+1` 大小的数组也是常见做法以避免边界条件。

## 2D 前缀和

原理（m x n 矩阵，0-based）：

```
pre[i][j] = sum of a[0..i][0..j]
构造:
pre[i][j] = a[i][j] + (i>0?pre[i-1][j]:0) + (j>0?pre[i][j-1]:0) - (i>0 && j>0 ? pre[i-1][j-1] : 0)
查询子矩阵 (x1,y1) 到 (x2,y2):
sum = pre[x2][y2] - (x1>0?pre[x1-1][y2]:0) - (y1>0?pre[x2][y1-1]:0) + (x1>0 && y1>0 ? pre[x1-1][y1-1] : 0)
```

实现注意：用动态分配的二维数组（单块内存或指针数组）。这里用单块（连续内存）实现，方便释放与索引。

```c
/* prefix_sum_2d.c
   编译: gcc prefix_sum_2d.c -o prefix_sum_2d
*/
#include <stdio.h>
#include <stdlib.h>

long long* malloc_2d(int rows, int cols) {
    // 返回指向 rows*cols 的连续内存，访问 indx = i*cols + j
    long long *arr = (long long*)calloc((size_t)rows * cols, sizeof(long long));
    if (!arr) { perror("calloc"); exit(EXIT_FAILURE); }
    return arr;
}

long long* build_prefix2d(const long long *a, int rows, int cols) {
    long long *pre = malloc_2d(rows, cols);
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            long long cur = a[i*cols + j];
            long long up = (i>0) ? pre[(i-1)*cols + j] : 0;
            long long left = (j>0) ? pre[i*cols + (j-1)] : 0;
            long long diag = (i>0 && j>0) ? pre[(i-1)*cols + (j-1)] : 0;
            pre[i*cols + j] = cur + up + left - diag;
        }
    }
    return pre;
}

long long range_sum2d(const long long *pre, int cols,
                      int x1, int y1, int x2, int y2) {
    long long total = pre[x2*cols + y2];
    long long up = (x1 > 0) ? pre[(x1-1)*cols + y2] : 0;
    long long left = (y1 > 0) ? pre[x2*cols + (y1-1)] : 0;
    long long diag = (x1 > 0 && y1 > 0) ? pre[(x1-1)*cols + (y1-1)] : 0;
    return total - up - left + diag;
}

int main() {
    int rows = 3, cols = 4;
    long long a[12] = {
        1, 2, 3, 4,
        5, 6, 7, 8,
        9,10,11,12
    };
    long long *pre = build_prefix2d(a, rows, cols);
    // 求子矩阵 (1,1) 到 (2,3)（含端点）即:
    // 6 7 8
    // 10 11 12  -> sum = 6+7+8+10+11+12 = 54
    printf("sum((1,1)-(2,3)) = %lld\n", range_sum2d(pre, cols, 1,1,2,3));
    free(pre);
    return 0;
}
```

说明与注意：

- 时空：构建 O(rows*cols)，查询 O(1)。
- 对矩阵边界条件（x1==0 或 y1==0）要小心 `- up - left + diag` 的组合。

## 2D 差分

用途：对矩形 `[x1..x2][y1..y2]` 做加值 `v`，用 2D 差分能把更新变成常数次操作，最终做 2D 前缀和恢复。

公式（0-based，使用 n x m 大小的 d）：
 对矩阵 `d`：

```
d[x1][y1] += v
if (y2+1 < m) d[x1][y2+1] -= v
if (x2+1 < n) d[x2+1][y1] -= v
if (x2+1 < n && y2+1 < m) d[x2+1][y2+1] += v
```

最后对 d 做两次前缀和（先行再列或先列再行，都行）得到最终矩阵。

实现（用连续内存）：

```c
/* diff_2d.c
   编译: gcc diff_2d.c -o diff_2d
*/
#include <stdio.h>
#include <stdlib.h>

long long* malloc_2d(int rows, int cols) {
    long long *arr = (long long*)calloc((size_t)rows * cols, sizeof(long long));
    if (!arr) { perror("calloc"); exit(EXIT_FAILURE); }
    return arr;
}

void range_add_2d(long long *d, int n, int m,
                  int x1, int y1, int x2, int y2, long long v) {
    if (x1 < 0 || x2 >= n || y1 < 0 || y2 >= m || x1 > x2 || y1 > y2) return;
    d[x1*m + y1] += v;
    if (y2 + 1 < m) d[x1*m + (y2+1)] -= v;
    if (x2 + 1 < n) d[(x2+1)*m + y1] -= v;
    if (x2 + 1 < n && y2 + 1 < m) d[(x2+1)*m + (y2+1)] += v;
}

long long* materialize_2d(long long *d, int n, int m) {
    // 先根据行方向做前缀和
    for (int i = 0; i < n; ++i) {
        for (int j = 1; j < m; ++j) {
            d[i*m + j] += d[i*m + (j-1)];
        }
    }
    // 再根据列方向做前缀和
    for (int j = 0; j < m; ++j) {
        for (int i = 1; i < n; ++i) {
            d[i*m + j] += d[(i-1)*m + j];
        }
    }
    // d 现在就是最终矩阵（注意：此函数会在原地修改 d 并返回）
    return d;
}

int main() {
    int n = 3, m = 4;
    long long *d = malloc_2d(n, m); // 初始化为 0

    // 做两次矩形更新
    range_add_2d(d, n, m, 0, 0, 1, 1, 5); // 在子矩阵 (0,0)-(1,1) 加 5
    range_add_2d(d, n, m, 1, 2, 2, 3, 7); // 在子矩阵 (1,2)-(2,3) 加 7

    long long *res = materialize_2d(d, n, m);

    printf("final matrix:\n");
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            printf("%lld ", res[i*m + j]);
        }
        printf("\n");
    }
    free(d); // res 指向同一块内存
    return 0;
}
```

说明：

- 时间：每次矩形更新 O(1)，最终 materialize O(n*m)（行前缀 + 列前缀）。
- 注意 `x2+1` / `y2+1` 的边界检查；构造 d 时通常分配 `n x m` 并在运行中检查 `+1` 边界；也可以分配 `(n+1) x (m+1)` 简化边界但要小心输出尺寸。

## 常见题型

1. **大量区间加值 + 最后输出数组** → 用 1D 差分（或 2D 差分）。
2. **大量区间查询（查询任意 [l,r] 的和）且数组不怎么改** → 用前缀和。
3. **实时修改并频繁查询** → 用树状数组（Fenwick）或线段树（不是这次核心，但与前缀和思想有关）。
4. **矩阵局部累加** → 2D 差分（如多次矩形加值）。
5. **字符出现次数区间统计** → 把字符转为多个前缀和（26 个前缀和数组）。