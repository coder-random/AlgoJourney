# 二分查找——你可能没注意的技巧

## **中点计算防止溢出**

很多人写成：

```c
int mid = (l + r) / 2;
```

如果 `l` 和 `r` 很大，可能会 **整型溢出**。
 正确写法：

```c
int mid = l + (r - l) / 2;
```

##  **边界条件不同，结果差异很大**

- `while (l <= r)` → 常用于精确查找某个元素。
- `while (l < r)` → 常用于查找边界（如第一个 ≥target 的位置）。

两者的区别在于 **循环退出条件**，要根据需求选择。

##  **查找左边界（lower_bound）**

很多时候需要找到第一个 **大于等于 target** 的位置，而不是精确等于。
 实现如下：

```c
int lowerBound(int arr[], int n, int target) {
    int l = 0, r = n;
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] < target) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l; // 返回第一个 >= target 的位置
}
```

## 查找右边界（upper_bound）

找到第一个 **大于 target** 的位置。

```c
int upperBound(int arr[], int n, int target) {
    int l = 0, r = n;
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] <= target) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l; // 返回第一个 > target 的位置
}
```

## 二分查找不止用于数组**

很多人以为二分查找只能在数组里用，其实只要问题满足 **单调性**，就能用二分。

常见场景：

- 最小化最大值 / 最大化最小值
- 求满足条件的最小值/最大值
- 判定性问题（YES/NO）转化为答案区间的二分

例如：

- **求最小船运天数**
- **最大化切木头的长度**
- **最小体力消耗**

这些都可以通过“答案二分”来解。

##  **模板化写法，减少出错**

建议准备两套常用模板：

### 精确查找

```c
while (l <= r) {
    int mid = l + (r - l) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) l = mid + 1;
    else r = mid - 1;
}
return -1;
```

### 查找边界

```c
while (l < r) {
    int mid = l + (r - l) / 2;
    if (check(mid)) r = mid; // 找左边界
    else l = mid + 1;
}
return l;
```

## 调试技巧

二分写错很常见，调试时：

- 打印 `l, r, mid` 的变化过程
- 用小数组手动模拟
- 特别注意 **退出条件** 是否能覆盖所有情况

**总结一句话**：
 二分查找不仅仅是“找某个数”，更强大的是它在 **判定性问题 + 单调性问题** 中的应用。掌握 **边界处理** 和 **答案二分**，你就能真正把二分查找用到各种算法题中。