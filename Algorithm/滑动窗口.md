## 什么是滑动窗口？

想象你有一排数字：

```
[ 2, 3, 1, 4, 6, 2, 5 ]
```

我们经常需要处理「连续的一段数字」，比如：

- **长度固定为 3** 的所有子数组和；
- **和不小于 8** 的最短子数组；
- **最长没有重复字符的子串**（对应字符串）；

这些问题的核心就是：我们要不断查看**一个连续区间**，而这个区间的起点和终点会不停往前滑动，就像一个“窗口”在数组上滑动。

## 两个指针 —— 窗口的边界

滑动窗口通常用两个变量：

- `left`（左指针，窗口起点）
- `right`（右指针，窗口终点）

**窗口 = [left, right] 这一段连续的元素。**

然后：

- `right++` → 窗口向右扩张，引入一个新元素。
- `left++` → 窗口从左收缩，丢掉一个元素。

这样窗口就会“滑动”起来。

##  一个最简单的例子 —— 固定长度窗口

问题：数组 `[2,3,1,4,6]`，求**所有长度为 3 的连续子数组和**。

方法：

1. 先算第一个窗口 `[2,3,1] = 6`。
2. 窗口右移：去掉最左边 `2`，加上新进来的 `4` → `6 - 2 + 4 = 8`。
3. 再右移：去掉 `3`，加上 `6` → `8 - 3 + 6 = 11`。

结果：`6, 8, 11`。

这就是**滑动窗口**的最基础形式：

> **每次移动窗口，只更新“进来一个、出去一个”，避免重复计算。**

## 第二个例子 —— 不固定长度窗口

问题：给你数组 `[2,3,1,2,4,3]`，求**和 ≥ 7 的最短子数组长度**。

做法：

1. `left=0,right=0`：窗口 `[2]`，和=2 (<7)。
2. `right=1`：窗口 `[2,3]`，和=5 (<7)。
3. `right=2`：窗口 `[2,3,1]`，和=6 (<7)。
4. `right=3`：窗口 `[2,3,1,2]`，和=8 (≥7)。满足条件了！
   - 更新答案长度=4。
   - 然后尝试移动 `left` 收缩 → 去掉 `2`，窗口 `[3,1,2]`，和=6 (<7)，不满足，停。
5. `right=4`：窗口 `[3,1,2,4]`，和=10 (≥7)。
   - 收缩：去掉 `3` → `[1,2,4]`，和=7，长度=3。
   - 再收缩：去掉 `1` → `[2,4]`，和=6 (<7)，停。
6. `right=5`：窗口 `[2,4,3]`，和=9 (≥7)。
   - 收缩：去掉 `2` → `[4,3]`，和=7，长度=2 。

最终答案 = 2（子数组 `[4,3]`）。

> 可以看出：
>
> - 右指针不断扩展窗口，保证覆盖所有元素。
> - 每次达到条件，就尽量移动左指针，缩小窗口，找最优解。

## 第三个例子 —— 字符串去重

问题：求字符串 `"abcabcbb"` 的最长不重复子串。

步骤：

1. `left=0,right=0` → `"a"`，有效。
2. `right=1` → `"ab"`，有效。
3. `right=2` → `"abc"`，有效，长度=3。
4. `right=3` → `"abca"`，重复了（`a`）。
   - 移动 `left`，直到没有重复 → `"bca"`，长度=3。
5. `right=4` → `"bcab"`，又重复了（`b`），继续收缩。
6. 最终最长长度 = 3。

> 这就是 **滑动窗口 + 哈希表**（记录每个字符是否出现）。

## 总结口诀

滑动窗口的三个核心步骤：

1. **右扩**：把新元素加入窗口。
2. **检查**：如果窗口“超标”了（重复/和太大/种类太多…），就左收缩。
3. **更新答案**：在窗口合法时更新最优解（最大/最小/计数）。

## 常见题型与对应体

1. **定长窗口（窗口长度 = k）**
   - 目标：窗口和/平均/最大值/固定 k 内的某种统计。
   - 手段：用一个滑动和（或维护队列/堆）`O(n)`。
2. **不定长窗口（条件是窗口内属性 ≤ / ≥ / = 某值）**
   - 例：最短子数组和 ≥ S（数组非负）；最长子串至多 K 种字符。
   - 手段：右扩直到「满足或刚刚违反」条件，再左收缩；在线更新答案。
3. **恰好 K 的转换**
   - `exactly(K)` 常转换为 `atMost(K) - atMost(K-1)`（会大大简化实现）。
4. **窗口内维护极值（滑动窗口最大/最小）**
   - 使用**单调双端队列**（deque）在 `O(n)` 内完成每个窗口的最大/最小值查询。
5. **含负数或更复杂约束时**
   - 简单滑动窗口不再可靠（因为窗口和可能变得非单调）。需要**前缀和 + 单调队列**或其他数据结构（见高级部分）。

## 模板

### 1) 定长窗口：长度为 k 的窗口最大和

```c
#include <stdio.h>
#include <limits.h>

// 返回长度为 k 的窗口最大和（假设 n >= k）
long long maxSumLenK(long long a[], int n, int k) {
    long long cur = 0, best = LLONG_MIN;
    for (int i = 0; i < n; ++i) {
        cur += a[i];
        if (i >= k) cur -= a[i - k];   // 移除离开的元素
        if (i >= k - 1 && cur > best) best = cur;
    }
    return best;
}
```

### 2) 最短子数组和 ≥ S（数组非负）

```c
#include <stdio.h>
#include <limits.h>

int minLenSubarraySum(int a[], int n, int S) {
    int left = 0, ans = INT_MAX;
    long long sum = 0;
    for (int right = 0; right < n; ++right) {
        sum += a[right];
        while (sum >= S) {
            int len = right - left + 1;
            if (len < ans) ans = len;
            sum -= a[left++];
        }
    }
    return ans == INT_MAX ? -1 : ans;
}
```

### 3) 最长子串——至多 K 种字符（字符假设 ASCII）

```c
#include <stdio.h>
#include <string.h>

int longestAtMostKDistinct(char *s, int K) {
    int cnt[256] = {0};
    int distinct = 0, left = 0, ans = 0;
    int n = strlen(s);
    for (int right = 0; right < n; ++right) {
        unsigned char c = s[right];
        if (cnt[c]++ == 0) distinct++;
        while (distinct > K) {
            unsigned char d = s[left++];
            if (--cnt[d] == 0) distinct--;
        }
        int len = right - left + 1;
        if (len > ans) ans = len;
    }
    return ans;
}
```

### 4) 滑动窗口最大值（单调队列 / 双端队列，返回每个长度 k 窗口的最大值）

```c
#include <stdio.h>
#include <stdlib.h>

// 简易 deque 存放索引
typedef struct {
    int *data;
    int head, tail; // data[head] ... data[tail-1] 有效
    int cap;
} Deque;

Deque* createDeque(int cap) {
    Deque *q = malloc(sizeof(Deque));
    q->data = malloc(sizeof(int) * cap);
    q->head = q->tail = 0;
    q->cap = cap;
    return q;
}
void push_back(Deque *q, int x) { q->data[q->tail++] = x; }
void pop_back(Deque *q) { --q->tail; }
void pop_front(Deque *q) { ++q->head; }
int front(Deque *q) { return q->data[q->head]; }
int backq(Deque *q) { return q->data[q->tail - 1]; }
int empty(Deque *q) { return q->head == q->tail; }

void slidingMax(int a[], int n, int k, int res[]) {
    Deque *q = createDeque(n);
    int ri = 0;
    for (int i = 0; i < n; ++i) {
        // 移出队首已不在窗口的索引
        if (!empty(q) && front(q) <= i - k) pop_front(q);
        // 保持队内单调下降（值越大在前）
        while (!empty(q) && a[backq(q)] <= a[i]) pop_back(q);
        push_back(q, i);
        if (i >= k - 1) res[ri++] = a[front(q)];
    }
    free(q->data); free(q);
}
```

> 复杂度：每个元素进入和离开 deque 最多一次 → O(n)。

## 重要变体与高级技巧

### A. “恰好 K” 类问题

如果题目要“恰好 K 个不同/特定性质”，通常做法：

```
exactly(K) = atMost(K) - atMost(K-1)
```

把「恰好」问题转成两个「至多」问题，常见于“恰好 K 个不同整数的子数组数”或“恰好 K 个不同字符的子串数”。

### B. 当数组有负数 —— 经典短子数组和 ≥ K（高级）

普通滑动窗口依赖于窗口和随右扩单调不减（若数组非负）。若有负数，窗口和可能降下来，简单左右收缩策略失效。常用解法：

**前缀和 + 单调队列（维护递增的前缀和索引）**，复杂但可在 O(n) 完成最短子数组和 ≥ K 的问题（见 LeetCode 862 类题）。

算法要点：

- 计算前缀和 `pref[i]`（`pref[0]=0`）。
- 使用 deque 存索引 `i`，并保持 `pref[i]` 单调递增（若新的 `pref[j] <= pref[back]`，pop_back）。
- 当 `pref[j] - pref[front] >= K` 时，用 `j - front` 更新答案并 pop_front。

## 调试技巧

- 在小样例上打印 `L,R,sum,cnt[...]` 等，中间状态有助定位何时“条件被错误触发”或“没收缩”。
- 手写一个最小可验证样例（长度 ≤ 10），用暴力解对比每一步的窗口集合。
- 检查边界：空字符串、k=0、所有元素都小于阈值、全部非负/全部负等。
- 若使用 deque，检查入队出队的时机与索引有效性（是否 pop 已过期索引 `i-k`）。