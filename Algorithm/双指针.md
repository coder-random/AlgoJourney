# 双指针

## 背景与核心思想

双指针是在“线性可遍历的序列或链表”中，用两个指针（或下标）协同前进，以一次或亚二重循环的代价解决问题的技巧。典型收益：将 O(n^2) 暴力降到 O(n) 或 O(n log n)。

两大范式：
- 对撞指针：从两端向中间移动。适合有序数组、回文判定、原地分区与反转、归并类“首尾逼近”问题。
- 快慢指针：同向前进，速度不同或维持间距。适合链表找环/入环点/中点，以及数组的稳定筛选和去重。

## 何时使用双指针

- 序列有“单调/可逼近”的性质：如有序数组中找目标和、边界移动能单调改变目标函数。
- 需要就地分区或重排：将满足某性质的元素推向左/右端，不追求稳定性时尤为高效。
- 链表结构问题：利用速度差（Floyd 判圈）、定位中点、构造固定距离删除结点。
- 原地数据清洗：“读指针扫描，写指针输出”的稳定筛选/去重。

非适用：
- 需要随机访问复杂统计、或区间不是“首尾可逼近”的。
- 需要离散化或图结构算法时。

## 不变量与复杂度直觉

- 不变量是正确性的核心。例如：
  - 分区时：[0, l) 全满足；[r, n) 全不满足；工作区间 [l, r)。
  - 三路分区：[0, low) 类别0；[low, mid) 类别1；[mid, high) 待分类；[high, n) 类别2。
  - 两数和：若当前和 < 目标，则左指针右移；若 > 目标，右指针左移。
  - 快慢指针：write 之前均为有效输出；fast/slow 间距固定等。
- 复杂度：指针单调不回头，总移动次数 O(n)。若伴随对数结构（本文件不涉及），则 O(n log n)。

## 实现要点与通用陷阱

- 索引与类型
  - 数组下标/长度建议用 size_t；printf 使用 %zu。
  - 求和/乘积注意溢出，必要时用 long long。
- C 字符串
  - 以 '\0' 结尾；strlen 是 O(n)，不要在循环中反复调用，先缓存长度。
- 谓词与分类函数
  - 分区/三路分区建议用函数指针提升复用性。
- 边界
  - 统一区间语义：例如 [l, r) 与 [l, r]；避免 off-by-one。
- 链表
  - 用 dummy 头结点简化删除头结点等边界。
  - Floyd 判圈相遇后寻找入环点的性质要牢记。

## 模板

下面模板均为最小可用形态，侧重“结构与不变量”，可直接粘贴使用。

```c
#include <stddef.h>
#include <stdbool.h>
#include <string.h>

static inline void swap_int(int* a, int* b) {
    int t = *a; *a = *b; *b = t;
}
```

### 一、对撞指针

1) 通用框架（数组）
- 场景：有序数组首尾逼近、回文、原地反转、按谓词分区等
- 不变量：每轮至少移动一端，保持问题所需的分区/单调性

```c
void two_ends_template(const int* a, size_t n /*, 其他参数如 target */) {
    if (n == 0) return;
    size_t l = 0, r = n - 1;
    while (l < r) {
        // 示例：两数之和
        // long long sum = (long long)a[l] + (long long)a[r];
        // if (sum < target) l++;
        // else if (sum > target) r--;
        // else { /* 命中处理 */ l++; r--; }
        // 确保每轮至少移动一个指针，避免死循环
        break; // 使用时删除此行，写入你的逻辑
    }
}
```

2) 按谓词分区（不稳定）
- 目标：pred(x) 为真放左侧，不真放右侧；顺序不稳定但速度快
- 不变量：[0, l) 全满足；[r, n) 全不满足；工作区间 [l, r)

```c
typedef bool (*pred_fn)(int x);

void partition_unstable(int* a, size_t n, pred_fn pred) {
    size_t l = 0, r = n; // 使用右开端 r
    while (l < r) {
        while (l < r && pred(a[l])) l++;
        while (l < r && !pred(a[r - 1])) r--;
        if (l < r) {
            swap_int(&a[l], &a[r - 1]);
            l++; r--;
        }
    }
}
```

3) 三路分区（荷兰国旗）
- 适合离散有限类别（返回 0/1/2 的分类器）
- 不变量：[0, low)=0；[low, mid)=1；[mid, high)=未定；[high, n)=2

```c
typedef int (*classify3_fn)(int x); // 返回 0,1,2

void dutch_flag_3way(int* a, size_t n, classify3_fn cls) {
    size_t low = 0, mid = 0, high = n;
    while (mid < high) {
        int c = cls(a[mid]);
        if (c == 0) {
            swap_int(&a[low], &a[mid]);
            low++; mid++;
        } else if (c == 1) {
            mid++;
        } else { // c == 2
            high--;
            swap_int(&a[mid], &a[high]);
        }
    }
}
```

4) 合并两个有序数组到输出（双向归并）
- 不变量：输出前缀始终是两个输入前缀的有序合并

```c
void merge_two_sorted(const int* a, size_t n,
                      const int* b, size_t m,
                      int* out /* size n+m */) {
    size_t i = 0, j = 0, k = 0;
    while (i < n && j < m) {
        if (a[i] <= b[j]) out[k++] = a[i++];
        else out[k++] = b[j++];
    }
    while (i < n) out[k++] = a[i++];
    while (j < m) out[k++] = b[j++];
}
```

5) 字符串回文判定（基础）
- 不变量：已比较的镜像字符均相等；l 与 r 向中间收缩

```c
bool is_palindrome_basic(const char* s) {
    size_t n = strlen(s);
    if (n == 0) return true;
    size_t l = 0, r = n - 1;
    while (l < r) {
        if (s[l] != s[r]) return false;
        l++; r--;
    }
    return true;
}
```

### 二、快慢指针

1) 稳定筛选（数组）
- 读写指针：read 扫描，pred 为真则写到 write 前缀
- 不变量：[0, write) 为有效输出；稳定保持相对顺序

```c
typedef bool (*pred_fn)(int x);

size_t stable_filter(int* a, size_t n, pred_fn pred) {
    size_t write = 0;
    for (size_t read = 0; read < n; read++) {
        if (pred(a[read])) a[write++] = a[read];
    }
    return write; // 新长度
}
```

2) 有序数组去重（每个元素保留一次）
- 不变量：[0, write) 保证无重复且有序

```c
size_t dedup_sorted_keep1(int* a, size_t n) {
    if (n == 0) return 0;
    size_t write = 1;
    for (size_t read = 1; read < n; read++) {
        if (a[read] != a[write - 1]) {
            a[write++] = a[read];
        }
    }
    return write;
}
```

3) 有序数组去重（最多保留 K 次）
- 技巧：检查 a[write - K] 与当前 a[read] 是否相等

```c
size_t dedup_sorted_keepK(int* a, size_t n, size_t K) {
    if (K == 0) return 0;
    size_t write = 0;
    for (size_t read = 0; read < n; read++) {
        if (write < K || a[read] != a[write - K]) {
            a[write++] = a[read];
        }
    }
    return write;
}
```

4) 链表：Floyd 判圈（是否有环）

```c
struct ListNode {
    int val;
    struct ListNode* next;
};

bool list_has_cycle(struct ListNode* head) {
    if (!head) return false;
    struct ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}
```

5) 链表：入环点

```c
struct ListNode* list_cycle_entry(struct ListNode* head) {
    if (!head) return NULL;
    struct ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            struct ListNode* p = head;
            while (p != slow) { p = p->next; slow = slow->next; }
            return p;
        }
    }
    return NULL;
}
```

6) 链表：中点（上/下中点）
- upper_mid = true 返回“上中点”；false 返回“下中点”

```c
struct ListNode* list_middle(struct ListNode* head, bool upper_mid) {
    if (!head) return NULL;
    struct ListNode *slow = head, *fast = head;
    if (upper_mid) {
        if (fast) fast = fast->next; // 调整初相位
    }
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}
```

7) 链表：删除倒数第 N 个结点（单趟）
- 不变量：fast 与 slow 保持 N 步间隔；fast 到尾时，slow 在待删结点前驱

```c
struct ListNode* list_remove_nth_from_end(struct ListNode* head, size_t n) {
    struct ListNode dummy = {0, head};
    struct ListNode *fast = &dummy, *slow = &dummy;

    for (size_t i = 0; i < n && fast; i++) fast = fast->next;
    if (!fast) return head; // n > 长度（按需处理策略）

    while (fast->next) {
        fast = fast->next;
        slow = slow->next;
    }
    struct ListNode* del = slow->next;
    if (del) slow->next = del->next; // 释放由调用方决定
    return dummy.next;
}
```



## 题型速览

- 对撞指针
  - 有序数组：两数之和/最接近和/平方有序归并
  - 字符串：回文判断、忽略非字母数字的回文（扩展）
  - 分区类：按奇偶/正负/区间阈值分区；三路分区（0/1/2）
  - 归并类：合并两个有序数组/链表
- 快慢指针
  - 数组：稳定过滤、去重（保 1/保 K 次）
  - 链表：判环、入环点、中点、删除倒数第 N

思考顺序：
1) 是否能用“首尾逼近”建立单调移动策略？
2) 是否是“读写分离”的稳定输出模式？
3) 是否是“快慢速度差”能揭示结构性质（环/中点/位置关系）？
